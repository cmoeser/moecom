/* Generated by Babel */
/* jshint esnext: true */

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _externalEs6PromiseMin = require('../external/es6-promise.min');

var _externalEs6PromiseMin2 = _interopRequireDefault(_externalEs6PromiseMin);

//TODO: make Promise = Promise.Promise

var Utils = (function () {
    function Utils() {
        _classCallCheck(this, Utils);

        var _this = this;

        var dynamicClasses = {
            fixed: '_fixed' // class for fixed body
        };

        this.constants = {
            breakpoints: {
                small: 767,
                medium: 1180,
                large: 1440
            }
        };

        this.scrollY = 0; // var to cache current window scroll

        // returns 'large', 'medium', or 'small' by querying a CSS set 'content' property on psuedo-element on body, see _global.scss
        this.getViewportSize = function () {
            return window.getComputedStyle(document.querySelector('body'), ':before').getPropertyValue('content').replace(/['"]/g, '');
        };
        this.loadUrl = function (url) {
            return new _externalEs6PromiseMin2['default'].Promise(function (resolve, reject) {
                var req = new XMLHttpRequest();
                req.open('GET', url);
                req.onload = function () {
                    if (req.status === 200) {
                        resolve(req.response);
                    } else {
                        reject(Error(req.statusText));
                    }
                };
                req.onerror = function () {
                    reject(Error('Network Error'));
                };
                req.send();
            });
        };
        this.loadScript = function (url) {
            return new _externalEs6PromiseMin2['default'].Promise(function (resolve, reject) {
                var ready = false,
                    tag = document.getElementsByTagName('script')[0],
                    script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = url;
                script.async = true;
                script.onload = script.onreadystatechange = function () {
                    if (!ready && (!this.readyState || this.readyState == 'complete' || this.readyState == 'loaded')) {
                        ready = true;
                        resolve(this);
                    }
                };

                script.onerror = script.onabort = reject;
                //var obj = JSON.parse(script);
                console.log('Script: ' + script);

                //tag.parentNode.insertBefore(script, tag);
            });
        };
        this.testFeature = function (feature) {
            if (window[feature] === undefined) {
                return false;
            }
            return true;
        };
        this.debounce = function (func, wait, immediate) {
            var timeout = undefined;
            var context = this,
                args = arguments;
            var later = function later() {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait || 100);
            if (callNow) {
                func.apply(context, args);
            }
        };

        var stopEvent = function stopEvent(e) {
            e.preventDefault();
            e.stopPropagation();
        };

        this.stopScroll = function (bool) {
            if (bool) {
                window.addEventListener('wheel', stopEvent);
                window.addEventListener('mousewheel', stopEvent);
            } else {
                window.removeEventListener('wheel', stopEvent);
                window.removeEventListener('mousewheel', stopEvent);
            }
        };
        this.getQueryVariable = function (variable) {
            var query = window.location.search.substring(1);
            var vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split("=");
                if (pair[0] == variable) {
                    return pair[1];
                }
            }
            return false;
        };

        // prevent scrolling on body, pass true to fix body, false to disable
        this.fixBody = function (bool) {
            if (bool) {
                _this.scrollY = window.scrollY; //cache scrollY
                document.body.className = document.body.className + ' ' + dynamicClasses.fixed;
            } else {
                var regex = new RegExp(' ' + dynamicClasses.fixed, 'g');
                document.body.className = document.body.className.replace(regex, ''); // replace all instances
                window.scroll(0, _this.scrollY); // set Y scroll to scrollY
            }
        };
        // Test if webkit-overflow-scrolling is supported
        this.webkitOverflowScrollingSupport = function () {
            var testDiv = document.createElement('div');
            document.documentElement.appendChild(testDiv);
            testDiv.style.WebkitOverflowScrolling = 'touch';
            var bool = 'getComputedStyle' in window && window.getComputedStyle(testDiv)['-webkit-overflow-scrolling'] === 'touch';
            document.documentElement.removeChild(testDiv);
            return bool;
        };

        //this.imagesLoaded = require('imagesloaded');
    }

    _createClass(Utils, [{
        key: 'getViewportSize',
        value: function getViewportSize() {
            return this.getViewportSize();
        }
    }, {
        key: 'loadUrl',
        value: function loadUrl(url) {
            this.loadUrl(url);
        }
    }, {
        key: 'loadScript',
        value: function loadScript(url) {
            this.loadScript(url);
        }
    }, {
        key: 'testFeature',
        value: function testFeature(feature) {
            this.testFeature(feature);
        }
    }, {
        key: 'debounce',
        value: function debounce(func, wait, immediate) {
            this.debounce(func, wait, immediate);
        }
    }, {
        key: 'fixBody',
        value: function fixBody(bool) {
            this.fixBody(bool);
        }
    }, {
        key: 'stopScroll',
        value: function stopScroll(bool) {
            this.stopScroll(bool);
        }
    }, {
        key: 'webkitOverflowScrollingSupport',
        value: function webkitOverflowScrollingSupport() {
            return this.webkitOverflowScrollingSupport();
        }
    }, {
        key: 'constants',
        value: function constants() {
            return this.constants;
        }
    }, {
        key: 'name',
        value: function name() {
            return "Utils";
        }
    }]);

    return Utils;
})();

exports['default'] = Utils;
module.exports = exports['default'];